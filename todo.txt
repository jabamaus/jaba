- A consequence of moving plugin inline in jaba file is it will be included in backtraces
- Add invocations.txt to each example which cam execute in multiple ways
- Ability to 'grab' a text plugin that auto-adds ability to generate a text file to cpp projects.
- Validate paths for missing / eg '../..debase-ruby_core_source/
- option in tests to log to stdout
- Consider whether JABA module is really adding much
- If targeting cpp, only create cpp and dependent types. Ignore other types and instances of those types.
- Allow sublclasses of Plugins. Useful in testing.
- Add text_plugin.rb to examples in docs
- Get rid of # frozen_string_literal: true in tests?
- Moving text into plugin has raised question about host. Need to set requied cpp_project_classname to ''. Not clean.
- Should | be allowed in ids? Probably not.
- Check error reporting in the case that there is an argument error inside Services#define. Needs to present internal callstack.
- not sure about using inspect_unquoted everywhere in error msgs to explicitly show symbols...
- localise error strings into a single file, using macros for variable substitution. As well as being better for standardisation could support multiple languages.
- jaba attr types could register option into JabaAttributeDefinition. noderef/compound types could use it.
- remove text plugin. Or even better turn into a compound attr and add to cpp.
- consider making all paths relative to jaba file when in defaults and shared definitions
- optimise copying of value options once they are more locked down.
- move JabaAttributeType base class into extend folder
- rename type: :compound to :compound?
- Have a look at RubyVM to try and precompile ruby
- Should :definition_root basedir_spec be able to take its value from the setting attr? Eg if globals attr specifies a definition root base spec it be relative to the user definition.
- Could be moving towards concept of a type requiring configuration
- Think about idea of lazy initialisation of types. Eg could move grab_bag into modules so they are always loaded but flag the type as lazy. When its is 'grabbed' it is initialised. 
- Support vcfprop at project level too
- Review whether '.' is allowed in :basename type. Maybe Introduce and allow_ext option.
- Introduce :extension type. Use for src_ext
- Add allowed platform specs to cpp#platforms reference doc somehow
- rename windows_x86 to win_86?
- Combine :symbol, :string and :symbol_or_string? Allow strings and symbols to be completely interchangeable?
- Standardise 'expected/available' error msg, eg Available: [a|b|c|]
- Regression tests for generated files!
- consider putting .jaba inside buildsystem
- Make build_output use an API so it can check that paths are absolute
- Not sure about build_root now. Is there one root too many? buildsystem_root and artefact can be set relative to jaba file in definitions or if runnning with jaba -B, that could set the buildsystem_root. 
- wrap -D target_host vs2019 into a command line switch
- sort out input system
- enforce that paths stay within their base dir spec
- Implement element deletion for hash attribute
- Split JabaAttributeDefinition into variants
- auto document plugin API
- Add a flag to jaba type to say its not top level instantiatable
- Add a file copy feature (install?). Could use custom build rule.
- Stats in docs, eg number of files in jaba release, size of zip.
- Finish off input manager cmd work
- Disallow nested src_roots 
- should string attr be allowed to be set to nil? Probably not.
- Stop globals from having dependencies.
- Add a 'referenced by' doc item for types.
- make jaba clean clean the generated src, the .vs folder, the 'build' folder and optionally the 'buildsystem' folder.
- Disallow ruby keywords as attr names, eg 'in' fails
- Consider making all attributes require a type
- Bed down value option type - eg call validators, testing
- reorg tests into core folder and cpp folder
- Stronger spec for value_options. Need to flag as array.
- Overhaul workspace project glob matching
- add cmd line test for
  - symbol attr
  - node ref attr
  - symbol or string attr
- add --list-globals option
- rename items to choices
* Implement jaba build command to build vs2019 solution
* Categories in solution files.
- flag to control whether absolute paths allowed in file/dir attrs. Eg build_root_offset is not an offset if absolute path used.
  Is it even a path attr?
- ability to have build tree out of src but projects in src? config option to base projdir off src_root instead of dest_root?
- Make defaults work per-file. Introduce global_defaults. Or a scope option to defaults.
* Automatically pull in dependencies into workspace
- attr def properties should have help string/notes...
- Disallow globals from referencing itself
- Allow default values to take options?
- RUBY LICENSE REQUIREMENTS
- consider having a globals per-type (eg cpp globals)
- validate when --src-root can be specified. Should be required if no .jaba files in cwd and disallowed if there are.
- Check attribute validators when parsing cmd line.
- Should jaba target one 'language' (type) per run? Eg C++, C#
- Employ did you mean style error reporting
  Error at basic_dll.jaba:8: 'defines' attribute not defined. Did you mean 'define'?
- validate platforms and architecture specs
- tag attrs as control flow attrs somehow for benefit of docs
- add slnproperty which can address sln sections. Particularly useful when used with ExtensibilityGlobals
- disband VSProj in favour of VSUtilities module
- Move title/note/example into module and include
- Have a command line switch to make all error messages contain absolute paths
- support for 'overriding' attribute defs when opening types, including calling super
- Make :nocheckexists do something
- Think more about project 'skus'.
- test :required flag compatibility
- Revisit set_to_default and wipe. Have way of clearing to default and clearing fully, but don't count that as set=true
- In defaults block are paths relative to the defaults file or the file of the definition being instanced?
- Allow 'axes' of configs. Bear in mind that platforms can be any string.
- Have some kind of spec for flag_options, eg

flag_option :export do
  note 'do exporting'
  compatibility do
    'only works on array and hash' if !array? && !hash?
    end
  end
end

- Having two arrays that reference the same type causes problems with :expose. Need to resolve this.
Need to make it so that don't expose if attribute is not single value. Also need to prevent exposing
if there are multiple attrs, with a warning.

  attr_array :valid_archs, type: :ref do
    note 'List of architectures supported by this platform'
    node_type :arch
    flags :required, :no_sort
  end

  attr_array :default_archs, type: :ref do
    note 'List of default target architectures for this platform'
    node_type :arch
    flags :required, :no_sort
  end

- check for duplicate filenames at plugin level, with proper error reporting
- Make _ID be id of the definition the code is in, such that it works even inside a block that is being executed in the context of a different jaba object
- Ability to reverse engineer jaba definitions from existing vsprojects
- Add check for re-entrancy when evaluating default blocks
- consistent method names across tests and consistent brackets on must_equal
- Create a table of attr mappings from jaba->premake->cmake
- Bring back boolean reader, eg if debug?
- Add 'underlying type' to attribute types? eg file.dir/src_spec are strings. Use this for extra validation and also to sort using casecmp
- resolve issues around sorting with mixed type elements
- Add wildcard validation to dir property

* Jaba does not try to be a complete cross platform 'API' to underlying build systems. It recognises where there is obvious commonality,
eg include paths, defines, libs, etc, but where things diverge across systems you can simply drop down and address that system directly,
because defining conditional data is very easy.
* Jaba aims to be lightweight. An executable and a bundle of ruby source files. Without sacrificing power and fleixibilty.
* Jaba aims to excel at validation and error reporting.

FAQ
Q: Why is Jaba so aggressive with sorting and stripping duplicates?
A: Because Jaba cares a lot about a clean build, and about deterministic minimum noise generation.

Q: Why is Jaba library code style not very 'ruby'?
A: The code is written in a style that is the easiest to step through in an IDE debugger, which is an essential tool in the development process


ouroveon todo
- workspace categories
- Allow debug?
- Support **.h as alternative to **/*.h
- Make shell build events use macros
- review whether static libs should have hard dependencies
- get rid of jaba.bat and Introduce jaba.exe
- add grab bag to reference docs
- optimisation settings
- Is ToolsVersion='16.0' needed?
- support for debugger working directory via .user file